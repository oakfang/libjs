{"name":"LibJS","tagline":"Making scoping better.","body":"### Welcome to LibJS.\r\nThis modular library is here to make sure you do not use code you do not need.\r\n\r\n### It's all about the modules\r\nWith LibJS, you divide your code into modules, like so:\r\n\r\n```\r\nlib.module('spam', function(moduleA, moduleB) {\r\n    var foo = moduleB.thingify('bar' * moduleA.CONST);\r\n    function poof (obj) {\r\n        return typeof obj === 'undefined' ? foo : bar;\r\n    }\r\n\r\n    return {poof: poof};\r\n});\r\n```\r\n\r\nEach module is registered to a global library of modules (obviously, you might as well create a local Lib, if you so desire).\r\n\r\nThe module's parameters (i.e. moduleA and moduleB, above) are also modules loaded into the lib. Just make sure they're loaded up.\r\n\r\nThen, you simply register your *main*:\r\n```\r\nlib.main(function (spam) {\r\n    // ...\r\n});\r\n```\r\n\r\nMake sure to call it after loading all modules.\r\n\r\n### But what do I do with all other published libraries I have?\r\nWhat a great question to have! Lets say you wish to use `jQuery.min.js`. Well, first of all, **don't put it as a script tag**. I know, I told you to make sure everything is loaded before using main. I kind of lied. See, you *can* specify a requirement you haven't loaded, but what this will do is search your `libpath` (which you can change prior to your man declaration thus: `lib.modulePath('/static/js').main(...);`) for `moduleName.js` and insert it dynamically into the dom. It will also harvest all changes to the global scope made by the script and move them into the module's scope.\r\n\r\n### But, sir, `jQuery.min` is NOT a legar parameter name!\r\nRight you are. You can use the aliasing syntax for that:\r\n```\r\nlib.module('myModule', function(/* jQuery.min */jquery){...});\r\n```\r\nThis will load jQuery.min.js as you jquey parameter. Isn't that just neat?\r\n\r\n### I just wish you had some better syntax for it\r\nWell, if you're not above using `sweet.js`, there's some cool features it adds. You should run `libc` from the `compiler` directory (using python2.7) with a single argument that is your directory of .sjs files.\r\n\r\nWhat's so great about the sweet support? Well, this:\r\n```\r\nmodule spam requires (moduleA, moduleB) {\r\n   defines {\r\n       sub moduleB.thingify;\r\n       subas moduleA.CONST, C;\r\n       var foo = thingify('bar' * C);\r\n       function poof (obj) {\r\n          return typeof obj === 'undefined' ? foo : bar;\r\n       }\r\n   }\r\n   exports {poof: poof}\r\n}\r\n```\r\n\r\n### What's in it for me?\r\nWell, not much, yet. Currently, there are a few cool modules that ship with `lib.js` (which you don't have you use, obviously). You can look at the demo page, and see, for example, the uses of `lib-route` and it's `libRoute` module. More features (especially regarding `lib-dom`) are under active development.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}